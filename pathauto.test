<?php
// $Id$

/**
 * @file
 * Functionality tests for Pathauto.
 *
 * @ingroup pathauto
 */

/**
 * Implements hook_simpletest_alter().
 */
function pathauto_simpletest_alter(&$groups) {
  // Enforce dependency on token for all pathauto tests.
  if (!drupal_get_filename('module', 'token')) {
    unset($groups['Pathauto']);
  }
}

/**
 * Helper test class with some added functions for testing.
 */
class PathautoUnitTestHelper extends DrupalWebTestCase {
  function setUp() {
    // Call parent::setUp() allowing test cases to pass further modules.
    $modules = func_get_args();
    $modules = array_merge(array('token', 'path', 'pathauto'), $modules);
    call_user_func_array(array('parent', 'setUp'), $modules);
  }

  function assertToken($type, $object, $token, $expected) {
    $tokens = pathauto_token_values($type, $object);
    $this->assertEqual($tokens[$token], $expected, t("Token value for [@token] was '!actual', expected value '!expected'.", array('@token' => $token, '!actual' => $tokens[$token], '!expected' => $expected)));
  }
}

/**
 * Unit tests for Pathauto functions.
 */
class PathautoUnitTestCase extends PathautoUnitTestHelper {
  public static function getInfo() {
    return array(
      'name' => 'Pathauto unit tests',
      'description' => 'Unit tests for Pathauto functions.',
      'group' => 'Pathauto',
    );
  }

  function setUp() {
    parent::setUp();
    module_load_include('inc', 'pathauto');
  }

  /**
   * Test _pathauto_get_schema_alias_maxlength().
   */
  function testGetSchemaAliasMaxLength() {
    $this->assertIdentical(_pathauto_get_schema_alias_maxlength(), 128);
  }

  /**
   * Test pathauto_pattern_load_by_entity().
   */
  function testPatternLoadByEntity() {
    variable_set('pathauto_node_story_en_pattern', ' story/en/[node:title] ');
    variable_set('pathauto_node_story_pattern', 'story/[node:title]');
    variable_set('pathauto_node_pattern', 'content/[node:title]');
    variable_set('pathauto_user_pattern', 'users/[user:name]');

    $tests = array(
      array('entity' => 'node', 'bundle' => 'story', 'language' => 'fr', 'expected' => 'story/[node:title]'),
      array('entity' => 'node', 'bundle' => 'story', 'language' => 'en', 'expected' => 'story/en/[node:title]'),
      array('entity' => 'node', 'bundle' => 'story', 'language' => '', 'expected' => 'story/[node:title]'),
      array('entity' => 'node', 'bundle' => 'page', 'language' => 'en', 'expected' => 'content/[node:title]'),
      array('entity' => 'user', 'bundle' => 'user', 'language' => '', 'expected' => 'users/[user:name]'),
      array('entity' => 'invalid-entity', 'bundle' => '', 'language' => '', 'expected' => ''),
    );
    foreach ($tests as $test) {
      $actual = pathauto_pattern_load_by_entity($test['entity'], $test['bundle'], $test['language']);
      $this->assertIdentical($actual, $test['expected'], t("pathauto_pattern_load_by_entity('@entity', '@bundle', '@language') returned '@actual', expected '@expected'", array('@entity' => $test['entity'], '@bundle' => $test['bundle'], '@language' => $test['language'], '@actual' => $actual, '@expected' => $test['expected'])));
    }
  }
}

/**
 * Helper test class with some added functions for testing.
 */
class PathautoTestHelper extends DrupalWebTestCase {
  protected $admin_user;

  function setUp() {
    // Call parent::setUp() allowing test cases to pass further modules.
    $modules = func_get_args();
    $modules = array_merge(array('path', 'token', 'pathauto'), $modules);
    call_user_func_array(array('parent', 'setUp'), $modules);

    // Set pathauto settings we assume to be as-is in this test.
    variable_set('pathauto_node_page_pattern', 'content/[title-raw]');

    $this->admin_user = $this->drupalCreateUser(array(
      'administer pathauto',
      'administer url aliases',
      'create url aliases',
      'administer nodes',
      'administer users',
    ));

    $this->drupalLogin($this->admin_user);
  }

  function assertEntityAlias($entity_type, $entity, $expected_alias) {
    switch ($entity_type) {
      case 'node':
        $path = 'node/' . $entity->nid;
        break;
      case 'user':
        $path = 'user/' . $entity->uid;
        break;
      default:
        return $this->fail(t('Unknown entity @type.', array('@type' => $entity_type)));
    }

    drupal_clear_path_cache();
    $alias = drupal_get_path_alias($path);
    $this->assertIdentical($alias, $expected_alias, t('Alias for %path was %actual, expected %expected.', array('%path' => $path, '%actual' => $alias, '%expected' => $expected_alias)));
  }
}

/**
 * Test basic pathauto functionality.
 */
class PathautoFunctionalTestCase extends PathautoTestHelper {
  public static function getInfo() {
    return array(
      'name' => 'Pathauto basic tests',
      'description' => 'Test basic pathauto functionality.',
      'group' => 'Pathauto',
    );
  }

  /**
   * Basic functional testing of Pathauto.
   */
  function testNodeEditing() {
    // Create node for testing.
    $random_title = $this->randomName(10);
    $title = ' Simpletest title ' . $random_title . ' [';
    $automatic_alias = 'content/simpletest-title-' . strtolower($random_title);
    $node = $this->drupalCreateNode(array('title' => $title, 'type' => 'page'));

    // Look for alias generated in the form.
    $this->drupalGet('node/' . $node->nid . '/edit');
    $this->assertFieldChecked('edit-pathauto-perform-alias');
    $this->assertFieldByName('path', $automatic_alias, 'Proper automated alias generated.');

    // Check whether the alias actually works.
    $this->drupalGet($automatic_alias);
    $this->assertText($title, 'Node accessible through automatic alias.');

    // Manually set the node's alias.
    $manual_alias = 'content/' . $node->nid;
    $edit = array(
      'pathauto_perform_alias' => FALSE,
      'path' => $manual_alias,
    );
    $this->drupalPost('node/' . $node->nid . '/edit', $edit, t('Save'));
    $this->assertText(t('@type @title has been updated', array('@type' => 'Page', '@title' => $title)));

    // Check that the automatic alias checkbox is now unchecked by default.
    $this->drupalGet('node/' . $node->nid . '/edit');
    $this->assertNoFieldChecked('edit-pathauto-perform-alias');
    $this->assertFieldByName('path', $manual_alias);

    // Submit the node form with the default values.
    $this->drupalPost(NULL, array(), t('Save'));
    $this->assertText(t('@type @title has been updated', array('@type' => 'Page', '@title' => $title)));

    // Test that the old (automatic) alias has been deleted and only accessible
    // through the new (manual) alias.
    $this->drupalGet($automatic_alias);
    $this->assertResponse(404, 'Node not accessible through automatic alias.');
    $this->drupalGet($manual_alias);
    $this->assertText($title, 'Node accessible through manual alias.');
  }

  /**
   * Test node operations.
   */
  function testNodeOperations() {
    $node1 = $this->drupalCreateNode(array('title' => 'node1'));
    $node2 = $this->drupalCreateNode(array('title' => 'node2'));

    // Delete all current URL aliases.
    db_query("DELETE FROM {url_alias}");

    $edit = array(
      'operation' => 'pathauto_update_alias',
      "nodes[{$node1->nid}]" => TRUE,
    );
    $this->drupalPost('admin/content/node', $edit, t('Update'));
    $this->assertText('Updated URL alias for 1 node.');

    $this->assertEntityAlias('node', $node1, 'content/' . $node1->title);
    $this->assertEntityAlias('node', $node2, 'node/' . $node2->nid);
  }

  /**
   * Test user operations.
   */
  function testUserOperations() {
    $account = $this->drupalCreateUser();

    // Delete all current URL aliases.
    db_query("DELETE FROM {url_alias}");

    $edit = array(
      'operation' => 'pathauto_update_alias',
      "accounts[{$account->uid}]" => TRUE,
    );
    $this->drupalPost('admin/user/user', $edit, t('Update'));
    $this->assertText('Updated URL alias for 1 user account.');

    $this->assertEntityAlias('user', $account, 'users/' . drupal_strtolower($account->name));
    $this->assertEntityAlias('user', $this->admin_user, 'user/' . $this->admin_user->uid);
  }
}

/*
 * Unit tests for the book tokens provided by Pathauto.
 */
class PathautoBookTokenTestCase extends PathautoUnitTestHelper {
  public static function getInfo() {
    return array(
      'name' => 'Pathauto book tokens',
      'description' => 'Unit tests for the book tokens provided by Pathauto.',
      'group' => 'Pathauto',
    );
  }

  function setUp() {
    parent::setUp('book');
    variable_set('book_allowed_types', array('book', 'page'));
    variable_set('pathauto_node_book_pattern', '[bookpathalias]/[title-raw]');
  }

  function testBookPathAlias() {
    // Add a non-book node.
    $non_book_node = $this->drupalCreateNode(array('type' => 'book'));
    $this->assertToken('node', $non_book_node, 'bookpathalias', '');

    // Add a root book page.
    $parent_node = $this->drupalCreateNode(array('type' => 'book', 'title' => 'Root', 'book' => array('bid' => 'new')));
    $this->assertToken('node', $parent_node, 'bookpathalias', '');

    // Add a first child page.
    $child_node1 = $this->drupalCreateNode(array('type' => 'book', 'title' => 'Sub page1', 'book' => array('bid' => $parent_node->book['bid'], 'plid' => $parent_node->book['mlid'])));
    $this->assertToken('node', $child_node1, 'bookpathalias', 'root');

    // Add a second child page.
    $child_node2 = $this->drupalCreateNode(array('type' => 'book', 'title' => 'Sub page2', 'book' => array('bid' => $parent_node->book['bid'], 'plid' => $parent_node->book['mlid'])));
    $this->assertToken('node', $child_node2, 'bookpathalias', 'root');

    // Add a child page on an existing child page.
    $sub_child_node1 = $this->drupalCreateNode(array('type' => 'book', 'title' => 'Sub-sub Page1', 'book' => array('bid' => $parent_node->book['bid'], 'plid' => $child_node1->book['mlid'])));
    $this->assertToken('node', $sub_child_node1, 'bookpathalias', 'root/sub-page1');
  }
}

/*
 * Unit tests for the taxonomy tokens provided by Pathauto.
 */
class PathautoTaxonomyTokenTestCase extends PathautoUnitTestHelper {
  protected $vocab;

  public static function getInfo() {
    return array(
      'name' => 'Pathauto taxonomy tokens',
      'description' => 'Unit tests for the taxonomy tokens provided by Pathauto.',
      'group' => 'Pathauto',
    );
  }

  function setUp() {
    parent::setUp('taxonomy');
    variable_set('pathauto_taxonomy_pattern', 'category/[vocab-raw]/[cat-raw]');
    // Reset the static taxonomy.module caches.
    taxonomy_vocabulary_load(0, TRUE);
    taxonomy_get_term(0, TRUE);
    $this->vocab = $this->addVocabulary();
  }

  /**
   * Test the [catpath] and [catalias] tokens.
   */
  function testCatTokens() {
    $term1 = $this->addTerm($this->vocab);
    $this->assertToken('taxonomy', $term1, 'catpath', $term1->name);
    $this->assertToken('taxonomy', $term1, 'catalias', "category/{$this->vocab->name}/{$term1->name}");

    $term2 = $this->addTerm($this->vocab, array('parent' => $term1->tid));
    $this->assertToken('taxonomy', $term2, 'catpath', "{$term1->name}/{$term2->name}");
    $this->assertToken('taxonomy', $term2, 'catalias', "category/{$this->vocab->name}/{$term2->name}");

    $term3 = $this->addTerm($this->vocab, array('parent' => $term2->tid, 'name' => ' foo/bar fer|zle '));
    $this->assertToken('taxonomy', $term3, 'catpath', "{$term1->name}/{$term2->name}/foobar-ferzle");
    $this->assertToken('taxonomy', $term3, 'catalias', "category/{$this->vocab->name}/foobar-ferzle");
  }

  /**
   * Test the [termpath] token.
   */
  function testTermTokens() {
    $term1 = $this->addTerm($this->vocab, array('weight' => 5));
    $term2 = $this->addTerm($this->vocab, array('weight' => -5));
    $term3 = $this->addTerm($this->vocab, array('weight' => 0));

    $node = $this->drupalCreateNode(array(
      'type' => 'story',
      'taxonomy' => array($term1->tid, $term2->tid, $term3->tid),
    ));

    $this->assertToken('node', $node, 'termpath', $term2->name);
    $this->assertToken('node', $node, 'termalias', "category/{$this->vocab->name}/{$term2->name}");
  }

  function addVocabulary(array $vocabulary = array()) {
    $vocabulary += array(
      'name' => drupal_strtolower($this->randomName(5)),
      'nodes' => array('story' => 'story'),
    );
    taxonomy_save_vocabulary($vocabulary);
    return (object) $vocabulary;
  }

  function addTerm(stdClass $vocabulary, array $term = array()) {
    $term += array(
      'name' => drupal_strtolower($this->randomName(5)),
      'vid' => $vocabulary->vid,
    );
    taxonomy_save_term($term);
    return (object) $term;
  }
}
